4.
import java.util.*;

public class NearestHospitalSimple {
    static class Edge {
        int dest, wt;
        Edge(int dest, int wt) { this.dest = dest; this.wt = wt; }
    }

    static class Pair implements Comparable<Pair> {
        int node, dist;
        Pair(int node, int dist) { this.node = node; this.dist = dist; }
        public int compareTo(Pair p) { return this.dist - p.dist; }
    }

    // Dijkstra Algorithm
    static int[] dijkstra(List<Edge>[] g, int src, int[] parent) {
        int n = g.length;
        int[] dist = new int[n];
        boolean[] vis = new boolean[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        Arrays.fill(parent, -1);
        dist[src] = 0;

        PriorityQueue<Pair> pq = new PriorityQueue<>();
        pq.add(new Pair(src, 0));

        while (!pq.isEmpty()) {
            Pair cur = pq.poll();
            if (vis[cur.node]) continue;
            vis[cur.node] = true;

            for (Edge e : g[cur.node]) {
                if (dist[cur.node] + e.wt < dist[e.dest]) {
                    dist[e.dest] = dist[cur.node] + e.wt;
                    parent[e.dest] = cur.node;
                    pq.add(new Pair(e.dest, dist[e.dest]));
                }
            }
        }
        return dist;
    }

    // Build path from parent[]
    static List<Integer> path(int[] parent, int dest) {
        List<Integer> p = new ArrayList<>();
        for (int i = dest; i != -1; i = parent[i]) p.add(i);
        Collections.reverse(p);
        return p;
    }

    // Find nearest hospital
    static void nearestHospital(List<Edge>[] g, int src, int[] hospitals) {
        int[] parent = new int[g.length];
        int[] dist = dijkstra(g, src, parent);
        int min = Integer.MAX_VALUE, nearest = -1;

        for (int h : hospitals)
            if (dist[h] < min) { min = dist[h]; nearest = h; }

        if (nearest == -1)
            System.out.println("No hospital reachable.");
        else {
            System.out.println("Nearest hospital: " + nearest + " | Time: " + min);
            System.out.println("Path: " + path(parent, nearest));
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter vertices and edges: ");
        int V = sc.nextInt(), E = sc.nextInt();
        List<Edge>[] g = new ArrayList[V];
        for (int i = 0; i < V; i++) g[i] = new ArrayList<>();

        System.out.println("Enter edges (u v w):");
        for (int i = 0; i < E; i++) {
            int u = sc.nextInt(), v = sc.nextInt(), w = sc.nextInt();
            g[u].add(new Edge(v, w));
            g[v].add(new Edge(u, w));
        }

        System.out.print("Enter source: ");
        int src = sc.nextInt();

        System.out.print("Enter number of hospitals: ");
        int h = sc.nextInt(), hospitals[] = new int[h];
        System.out.println("Enter hospital nodes:");
        for (int i = 0; i < h; i++) hospitals[i] = sc.nextInt();

        nearestHospital(g, src, hospitals);

        // Dynamic updates
        System.out.print("Enter number of traffic updates: ");
        int updates = sc.nextInt();
        for (int i = 0; i < updates; i++) {
            System.out.print("Update " + (i + 1) + " (u v new_w): ");
            int u = sc.nextInt(), v = sc.nextInt(), w = sc.nextInt();

            // Update both directions
            for (Edge e : g[u]) if (e.dest == v) e.wt = w;
            for (Edge e : g[v]) if (e.dest == u) e.wt = w;

            System.out.println("Updated traffic between " + u + " and " + v + " = " + w);
            nearestHospital(g, src, hospitals);
        }
        sc.close();
    }
}   

Enter vertices and edges: 
6 7
Enter edges (u v w):
0 1 4
0 2 2
1 2 5
1 3 10
2 4 3
4 3 4
3 5 11
Enter source: 
0
Enter number of hospitals: 
2
Enter hospital nodes:
3 5
